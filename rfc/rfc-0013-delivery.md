# RFC 0013 Delivery

## Summary

This RFC proposes the introduction of four new resources to the carto.run/v1alpha1 API group to handle application delivery (i.e., CD, validation, and promotion).

## Motivation

Cartographer’s `SupplyChain` allows application operators to pave a path from app source code to GitOps-ready K8s configuration.
However, it does not handle deployment and promotion of that K8s configuration.

## Detailed Explanation

This RFC proposes the introduction of four new resources to the carto.run/v1alpha1 API group to handle this use case: `clusterdeliveries`, `deliverables`, `clusterdeploytemplates`, and `clusterdeliverytemplates`.

- **ClusterDeliveries** are cluster-scoped resources that enable application operators to define continuous delivery workflows.
  Delivery is analogous to SupplyChain, in that it specifies a list of resources that are created when requested by the developer.
  However, Deliveries are used to specify how K8s configuration is delivered to a series of environments (after it is generated by a SupplyChain).
  
- **Deliverables** are namespaced resources that enable application developers to specify K8s configuration.
  A Deliverable is analogous to a Workload, in that it instantiates the resources defined by the Delivery.
  
- **ClusterDeployTemplates** are cluster-scoped resources that enable application operators to specify resource templates that deploy environments.
  ClusterDeployTemplates take a single source artifact and return a single deployment artifact. 
  
  source -> deployment

- **ClusterDeliveryTemplates** are cluster-scoped resources that enable application operators to specify resource templates that perform validations on a particular deployed environment.
  ClusterDeliveryTemplates take a deployment artifact and any number of additional source artifacts. They return a single deployment artifact.
  
  deployment, source[] -> deployment

In addition to these resources, the following existing resources are valid in a ClusterDelivery:

- **ClusterSourceTemplates** are cluster-scoped resources that enable application operators to specify resource templates that process k8s configuration and output a revision of k8s configuration.
  In the context of ClusterDelivery, ClusterSourceTemplates take any number of source and config artifacts and return a single source artifact. 
  
  config[], source[] -> source

- **ClusterTemplates** are cluster-scoped resources that enable application operators to specify resource templates that process k8s configuration and have no output.
  In the context of ClusterDelivery, ClusterTemplates take any number of source and config artifacts and return nothing. 
  
  config[], source[] -> X
  
ClusterDeployTemplates resource specs are only modified when their returned deployment revision is no longer being processed by any ClusterDeliveryTemplate resources.
This prevents an environment from changing while it is being validated by a ClusterDeliveryTemplate resource.

Deployment artifacts represent a revision of K8s configuration source and therefore use the same structure as source artifacts.
When needed, deployment artifacts may be “cast” into source artifacts, because a deployment revision is a type of source revision.
For example, a ClusterTemplate that promotes a commit containing K8s configuration to a production branch might consume that commit as a deployment artifact from a ClusterDeliveryTemplate that validated the deployment.
See the Staging Cluster example below.


## Rationale and Alternatives

Rationale:
- We should de-couple build (CI) and deployment (CD)
- SupplyChain takes application source code as input (via Workload), not K8s config

Alternatives:
- Deployment validations could be integrated into the ClusterDeployTemplate to avoid synchronization complexities
- Do nothing, keep using SupplyChain for deployment
- Do nothing, don't address CD

## Implementation

### API

Deliverable
```yaml
apiVersion: carto.run/v1alpha1
kind: Deliverable
metadata:
  name: <name>
  labels:
    app.tanzu.vmware.com/deliverable-type: <type>
spec:
  source:
    git:
      url: <url>
      subPath: <path>
      ref:
        branch: <branch>
```

ClusterDelivery
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDelivery
metadata:
  name: <name>
spec:
  selector:
    app.tanzu.vmware.com/deliverable-type: <type>
  resources:
    - name: config-provider
      templateRef:
        kind: <template-kind>
        name: <template-name>
      deployment: # kind=ClusterDeliveryTemplate 
        resource: <resource-name>
      sources: # kind=*
      - resource: <resource-name>
      configs: # kind=ClusterSourceTemplate
      - resource: <resource-name>

```

ClusterSourceTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterSourceTemplate
metadata:
  name: <name>
spec:
  urlPath: <jsonpath-in-status>
  revisionPath: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

ClusterDeployTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeployTemplate
metadata:
  name: <name>
spec:
  observedCompletion: # uses observedGeneration
    succeeded:
      key: <jsonpath-in-status>
      value: <expected-value>
    failed:
      key: <jsonpath-in-status>
      value: <expected-value>
  observedMatches: # alternative to observedCompletion
  - input: <jsonpath-in-spec>
    output: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

ClusterDeliveryTemplate
```yaml
apiVersion: carto.run/v1alpha1
kind: ClusterDeliveryTemplate
metadata:
  name: <name>
spec:
  observedCompletion: # uses observedGeneration
    succeeded:
      key: <jsonpath-in-status>
      value: <expected-value>
    failed:
      key: <jsonpath-in-status>
      value: <expected-value>
  observedMatches: # alternative to observedCompletion
  - input: <jsonpath-in-spec>
    output: <jsonpath-in-status>

  template: <jsonpath-style-template>
  ytt: <ytt-style-template-string>

```

